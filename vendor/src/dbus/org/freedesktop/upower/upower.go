/*This file is automatically generated by pkg.deepin.io/dbus-generator. Don't edit it*/
package upower

import "pkg.deepin.io/lib/dbus"
import "pkg.deepin.io/lib/dbus/property"
import "reflect"
import "sync"
import "runtime"
import "fmt"
import "errors"

/*prevent compile error*/
var _ = fmt.Println
var _ = runtime.SetFinalizer
var _ = sync.NewCond
var _ = reflect.TypeOf
var _ = property.BaseObserver{}

type Upower struct {
	Path     dbus.ObjectPath
	DestName string
	core     *dbus.Object

	signals       map[<-chan *dbus.Signal]struct{}
	signalsLocker sync.Mutex

	LidIsPresent  *dbusPropertyUpowerLidIsPresent
	LidIsClosed   *dbusPropertyUpowerLidIsClosed
	OnBattery     *dbusPropertyUpowerOnBattery
	DaemonVersion *dbusPropertyUpowerDaemonVersion
}

func (obj *Upower) _createSignalChan() <-chan *dbus.Signal {
	obj.signalsLocker.Lock()
	ch := getBus().Signal()
	obj.signals[ch] = struct{}{}
	obj.signalsLocker.Unlock()
	return ch
}
func (obj *Upower) _deleteSignalChan(ch <-chan *dbus.Signal) {
	obj.signalsLocker.Lock()
	delete(obj.signals, ch)
	getBus().DetachSignal(ch)
	obj.signalsLocker.Unlock()
}
func DestroyUpower(obj *Upower) {
	obj.signalsLocker.Lock()
	for ch, _ := range obj.signals {
		getBus().DetachSignal(ch)
	}
	obj.signalsLocker.Unlock()

	obj.LidIsPresent.Reset()
	obj.LidIsClosed.Reset()
	obj.OnBattery.Reset()
	obj.DaemonVersion.Reset()
}

func (obj *Upower) GetCriticalAction() (action string, _err error) {
	_err = obj.core.Call("org.freedesktop.UPower.GetCriticalAction", 0).Store(&action)
	if _err != nil {
		fmt.Println(_err)
	}
	return
}

func (obj *Upower) GetDisplayDevice() (device dbus.ObjectPath, _err error) {
	_err = obj.core.Call("org.freedesktop.UPower.GetDisplayDevice", 0).Store(&device)
	if _err != nil {
		fmt.Println(_err)
	}
	return
}

func (obj *Upower) EnumerateDevices() (devices []dbus.ObjectPath, _err error) {
	_err = obj.core.Call("org.freedesktop.UPower.EnumerateDevices", 0).Store(&devices)
	if _err != nil {
		fmt.Println(_err)
	}
	return
}

func (obj *Upower) ConnectDeviceRemoved(callback func(arg0 dbus.ObjectPath)) func() {
	__conn.BusObject().Call("org.freedesktop.DBus.AddMatch", 0,
		"type='signal',path='"+string(obj.Path)+"', interface='org.freedesktop.UPower',sender='"+obj.DestName+"',member='DeviceRemoved'")
	sigChan := obj._createSignalChan()
	go func() {
		for v := range sigChan {
			if v.Path != obj.Path || v.Name != "org.freedesktop.UPower.DeviceRemoved" || 1 != len(v.Body) {
				continue
			}
			if reflect.TypeOf(v.Body[0]) != reflect.TypeOf((*dbus.ObjectPath)(nil)).Elem() {
				continue
			}

			callback(v.Body[0].(dbus.ObjectPath))
		}
	}()
	return func() {
		obj._deleteSignalChan(sigChan)
	}
}

func (obj *Upower) ConnectDeviceAdded(callback func(arg0 dbus.ObjectPath)) func() {
	__conn.BusObject().Call("org.freedesktop.DBus.AddMatch", 0,
		"type='signal',path='"+string(obj.Path)+"', interface='org.freedesktop.UPower',sender='"+obj.DestName+"',member='DeviceAdded'")
	sigChan := obj._createSignalChan()
	go func() {
		for v := range sigChan {
			if v.Path != obj.Path || v.Name != "org.freedesktop.UPower.DeviceAdded" || 1 != len(v.Body) {
				continue
			}
			if reflect.TypeOf(v.Body[0]) != reflect.TypeOf((*dbus.ObjectPath)(nil)).Elem() {
				continue
			}

			callback(v.Body[0].(dbus.ObjectPath))
		}
	}()
	return func() {
		obj._deleteSignalChan(sigChan)
	}
}

type dbusPropertyUpowerLidIsPresent struct {
	*property.BaseObserver
	core *dbus.Object
}

func (this *dbusPropertyUpowerLidIsPresent) SetValue(notwritable interface{}) {
	fmt.Println("org.freedesktop.UPower.LidIsPresent is not writable")
}

func (this *dbusPropertyUpowerLidIsPresent) Get() bool {
	return this.GetValue().(bool)
}
func (this *dbusPropertyUpowerLidIsPresent) GetValue() interface{} /*bool*/ {
	var r dbus.Variant
	err := this.core.Call("org.freedesktop.DBus.Properties.Get", 0, "org.freedesktop.UPower", "LidIsPresent").Store(&r)
	if err == nil && r.Signature().String() == "b" {
		return r.Value().(bool)
	} else {
		fmt.Println("dbusProperty:LidIsPresent error:", err, "at org.freedesktop.UPower")
		return *new(bool)
	}
}
func (this *dbusPropertyUpowerLidIsPresent) GetType() reflect.Type {
	return reflect.TypeOf((*bool)(nil)).Elem()
}

type dbusPropertyUpowerLidIsClosed struct {
	*property.BaseObserver
	core *dbus.Object
}

func (this *dbusPropertyUpowerLidIsClosed) SetValue(notwritable interface{}) {
	fmt.Println("org.freedesktop.UPower.LidIsClosed is not writable")
}

func (this *dbusPropertyUpowerLidIsClosed) Get() bool {
	return this.GetValue().(bool)
}
func (this *dbusPropertyUpowerLidIsClosed) GetValue() interface{} /*bool*/ {
	var r dbus.Variant
	err := this.core.Call("org.freedesktop.DBus.Properties.Get", 0, "org.freedesktop.UPower", "LidIsClosed").Store(&r)
	if err == nil && r.Signature().String() == "b" {
		return r.Value().(bool)
	} else {
		fmt.Println("dbusProperty:LidIsClosed error:", err, "at org.freedesktop.UPower")
		return *new(bool)
	}
}
func (this *dbusPropertyUpowerLidIsClosed) GetType() reflect.Type {
	return reflect.TypeOf((*bool)(nil)).Elem()
}

type dbusPropertyUpowerOnBattery struct {
	*property.BaseObserver
	core *dbus.Object
}

func (this *dbusPropertyUpowerOnBattery) SetValue(notwritable interface{}) {
	fmt.Println("org.freedesktop.UPower.OnBattery is not writable")
}

func (this *dbusPropertyUpowerOnBattery) Get() bool {
	return this.GetValue().(bool)
}
func (this *dbusPropertyUpowerOnBattery) GetValue() interface{} /*bool*/ {
	var r dbus.Variant
	err := this.core.Call("org.freedesktop.DBus.Properties.Get", 0, "org.freedesktop.UPower", "OnBattery").Store(&r)
	if err == nil && r.Signature().String() == "b" {
		return r.Value().(bool)
	} else {
		fmt.Println("dbusProperty:OnBattery error:", err, "at org.freedesktop.UPower")
		return *new(bool)
	}
}
func (this *dbusPropertyUpowerOnBattery) GetType() reflect.Type {
	return reflect.TypeOf((*bool)(nil)).Elem()
}

type dbusPropertyUpowerDaemonVersion struct {
	*property.BaseObserver
	core *dbus.Object
}

func (this *dbusPropertyUpowerDaemonVersion) SetValue(notwritable interface{}) {
	fmt.Println("org.freedesktop.UPower.DaemonVersion is not writable")
}

func (this *dbusPropertyUpowerDaemonVersion) Get() string {
	return this.GetValue().(string)
}
func (this *dbusPropertyUpowerDaemonVersion) GetValue() interface{} /*string*/ {
	var r dbus.Variant
	err := this.core.Call("org.freedesktop.DBus.Properties.Get", 0, "org.freedesktop.UPower", "DaemonVersion").Store(&r)
	if err == nil && r.Signature().String() == "s" {
		return r.Value().(string)
	} else {
		fmt.Println("dbusProperty:DaemonVersion error:", err, "at org.freedesktop.UPower")
		return *new(string)
	}
}
func (this *dbusPropertyUpowerDaemonVersion) GetType() reflect.Type {
	return reflect.TypeOf((*string)(nil)).Elem()
}

func NewUpower(destName string, path dbus.ObjectPath) (*Upower, error) {
	if !path.IsValid() {
		return nil, errors.New("The path of '" + string(path) + "' is invalid.")
	}

	core := getBus().Object(destName, path)

	obj := &Upower{Path: path, DestName: destName, core: core, signals: make(map[<-chan *dbus.Signal]struct{})}

	obj.LidIsPresent = &dbusPropertyUpowerLidIsPresent{&property.BaseObserver{}, core}
	obj.LidIsClosed = &dbusPropertyUpowerLidIsClosed{&property.BaseObserver{}, core}
	obj.OnBattery = &dbusPropertyUpowerOnBattery{&property.BaseObserver{}, core}
	obj.DaemonVersion = &dbusPropertyUpowerDaemonVersion{&property.BaseObserver{}, core}

	getBus().BusObject().Call("org.freedesktop.DBus.AddMatch", 0, "type='signal',path='"+string(path)+"',interface='org.freedesktop.DBus.Properties',sender='"+destName+"',member='PropertiesChanged'")
	getBus().BusObject().Call("org.freedesktop.DBus.AddMatch", 0, "type='signal',path='"+string(path)+"',interface='org.freedesktop.UPower',sender='"+destName+"',member='PropertiesChanged'")
	sigChan := obj._createSignalChan()
	go func() {
		typeString := reflect.TypeOf("")
		typeKeyValues := reflect.TypeOf(map[string]dbus.Variant{})
		typeArrayValues := reflect.TypeOf([]string{})
		for v := range sigChan {
			if v.Name == "org.freedesktop.DBus.Properties.PropertiesChanged" &&
				len(v.Body) == 3 &&
				reflect.TypeOf(v.Body[0]) == typeString &&
				reflect.TypeOf(v.Body[1]) == typeKeyValues &&
				reflect.TypeOf(v.Body[2]) == typeArrayValues &&
				v.Body[0].(string) == "org.freedesktop.UPower" {
				props := v.Body[1].(map[string]dbus.Variant)
				for key, _ := range props {
					if false {
					} else if key == "LidIsPresent" {
						obj.LidIsPresent.Notify()

					} else if key == "LidIsClosed" {
						obj.LidIsClosed.Notify()

					} else if key == "OnBattery" {
						obj.OnBattery.Notify()

					} else if key == "DaemonVersion" {
						obj.DaemonVersion.Notify()
					}
				}
			} else if v.Name == "org.freedesktop.UPower.PropertiesChanged" && len(v.Body) == 1 && reflect.TypeOf(v.Body[0]) == typeKeyValues {
				for key, _ := range v.Body[0].(map[string]dbus.Variant) {
					if false {
					} else if key == "LidIsPresent" {
						obj.LidIsPresent.Notify()

					} else if key == "LidIsClosed" {
						obj.LidIsClosed.Notify()

					} else if key == "OnBattery" {
						obj.OnBattery.Notify()

					} else if key == "DaemonVersion" {
						obj.DaemonVersion.Notify()
					}
				}
			}
		}
	}()

	runtime.SetFinalizer(obj, func(_obj *Upower) { DestroyUpower(_obj) })
	return obj, nil
}
